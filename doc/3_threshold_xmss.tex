\section{Thresholdizing XMSS}
The downside of building a threshold hash-based signature by leveraging a SNARK system as mentioned above is that the aggregation of threshold signatures would not be straightforward (since threshold signatures are proofs instead of raw hash-based signatures).
In the case of the Beacon chain where threshold signatures occur \textit{before} aggregation duties, it is imperative for distributed validator middlewares to output signatures that can be aggregated according to the protocol.
Therefore, this section focuses on constructions which lead to threshold Winternitz signatures that are indistinguishable from non-threshold ones, as in \BLS.
\subsection{Distributed hash-based signatures with Boolean shares.}
Distributed variants of hash-based signatures, including \XMSS, have been explored by Kelsey, Lang and Lucks in~\cite{cryptoeprint:2022/241} where they introduce $n$-of-$n$ and $k$-of-$n$ threshold signature schemes which rely on Boolean shares.
%\paragraph{$n$-of-$n$ setting.}
For the $n$-of-$n$ setting, a trusted dealer starts from an existing Merkle tree and splits each \WOTS secret key $\mathsf{sk_i}$ by generating $n$ random values $\mathsf{r}^0_i,\cdots,\mathsf{r}^{n-1}_i$ to compute $\mathsf{r}^h_i = \mathsf{r}^0_i \oplus \mathsf{r}^1_i \oplus \cdots \oplus \mathsf{r}^{n-1}_i \oplus \mathsf{sk}_i$.
This introduces an additional party called the \textit{helper} whose role is to store and provide the relevant helper shares whenever required.
That way, to produce a \WOTS using for $\mathsf{sk}_i$, each party can sign independently using its Boolean key share assuming the aggregator has access to the helper share $r^h_i$.
Note that the trusted dealer not only has to produce helper shares for \WOTS secret keys, but also for each Merkle paths, inducing high memory requirement on the helper.
%\mto generate random values $n$ random values and to exclusive-OR them
To minimize memory usage for the parties, the key shares are actually generated pseudorandomly using a \PRF along with a secret seed as detailed in Algorithm~\ref{alg:bool_split_n}.
To turn their $n$-of-$n$ scheme into a $k$-of-$n$ threshold scheme, they propose to instantiate a Merkle tree that contains keys for all possible $\binom{n}{k}$ quorums.
Beyond complexity, this increases the height of the Merkle tree and hence the signature size as well as the memory requirements for the helper.
Because their designs are incompatible with distributed key generation (DKG) methods, we investigate other solutions instead. 

\begin{myalgorithm}{Split a Merkle tree of WOTS keys into distributed key shares for $n$-of-$n$ signatures, according to~\cite{cryptoeprint:2022/241}.}
Input parameters:
\begin{itemize}
\itemsep-.5em
\item Merkle tree built out of a $n$-bit hash function $H$ and $2^h$ \WOTS secret keys $\mathsf{sk}_0,\cdots,\mathsf{sk}_{2^h-1}$ to sign $n=vw$-bit messages (\textit{i.e.}, $\mathsf{sk}_i = (\mathsf{sk}_{i,0}, \cdots, \mathsf{sk}_{i,v-1})$).
\item A pseudorandom function $\mathsf{PRF}_K(x,l)$ parametrized by a $k$-bit key $K$ which takes as input a seed $x$ along with the output bit length $l$.
\item A set of distributed parties $\mathcal{P}$.
\end{itemize}

Output parameters:
\vspace{-.75em}
\begin{itemize}
\itemsep-.5em
\item Secret keys $\mathsf{key}_p$ for each party $p \in \mathcal{P}$.
\item Helper shares $\mathsf{sk}^h_{i,j}$ and $\mathsf{path}^h_{i}$ for $i \in \{0,\cdots,2^h-1\}$ and $j \in \{0, \cdots, v-1\}$.
\end{itemize}

\ForEach(\tcp*[f]{picks secrets at random for each party}){$p \in \mathcal{P}$} {
	$\mathsf{key}_p \xleftarrow[]{\$} \{0,1\}^k $ 
}

%\For(\tcp*[f]{for each leaf}){$j=0$ \KwTo $2^h$} {
\For(\tcp*[f]{builds Merkle path helper shares}){$i=0$ \KwTo $2^h-1$} {
	$\mathsf{path}^h_i \leftarrow \mathsf{path}_i$\\
	\ForEach(){$p \in \mathcal{P}$} {
		$\mathsf{path}^h_i \leftarrow \mathsf{path}^h_i \oplus \mathsf{PRF}_{\mathsf{key}_p}\big((\mathsf{domain_{path}}, i), nh\big)$\\
	}
}
	
\For(\tcp*[f]{builds WOTS key helper shares}){$i=0$ \KwTo $2^h-1$} {
	\For(\tcp*[f]{for each secret key component}){$j=0$ \KwTo $v-1$} {
		\For(\tcp*[f]{for each w-bit chunk to sign\space}){$c=0$ \KwTo $2^w-1$} {
		$\mathsf{sk}^h_{i,j}[c] \leftarrow H^c(\mathsf{sk}_{i,j})$ \\
		\ForEach(){$p \in \mathcal{P}$} {
			$\mathsf{sk}^h_{i,j}[c] \leftarrow \mathsf{sk}^h_{i,j}[c] \oplus \mathsf{PRF}_{\mathsf{key}_p}\big((\mathsf{domain_{key}}, i, j, c), n\big)$\\
			}
		}
	}

}
\label{alg:bool_split_n}
\end{myalgorithm}

\subsection{Leveraging Shamir Secret Sharing}
Turning \WOTS into a threshold scheme presents no significant challenges as one can simply apply a secret sharing scheme on the secret keys so that messages can be partially signed non-interactively.
However, the difficulty arises when Merkle trees come into play: computing Merkle paths from secret key shares requires to process all hash function calls in a multi-party computation (MPC) fashion.
This would be highly impractical in low latency scenarios such as performing validator duties on Ethereum, as the time to produce a threshold signature could not fit within an epoch (see \textit{e.g.} the work from Cozzo and Smart~\cite{cryptoeprint:2019/1060} which estimates around 85 minutes to compute a threshold \textsf{SPHINCS+} signature with \textsf{SHA-3} as the underlying hash function).
A possible workaround is to store Merkle paths along with \WOTS secret keys so that it is not necessary to recompute them on-the-fly.



Bear in mind that avoiding any MPC hash invocation implies that \WOTS secret keys cannot be generated pseudo-randomly from a secret seed shared amongst participants, further increasing memory consumption.
 
Still, even if all parties store their own \WOTS secret key shares and corresponding Merkle paths, they cannot sign non-interactively.
Indeed, \XMSS not being a deterministic signature scheme, the signers have to agree on a random number to be included in the randomized message digest calculation.
